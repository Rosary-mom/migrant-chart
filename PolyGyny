<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verfeinerte Gamifizierte Simulation: Re-Migration bis 2050 & Volkshygiene mit Umweltauswirkungen</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 1200px; margin: auto; }
        .slider { width: 100%; margin: 10px 0; }
        .output { font-weight: bold; }
        button { padding: 10px 20px; background: #4CAF50; color: white; border: none; cursor: pointer; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background: #f2f2f2; }
        .badge { padding: 5px 10px; border-radius: 5px; color: white; }
        .stable { background: green; }
        .boom { background: blue; }
        .collapse { background: red; }
        .risk { background: orange; }
        .green { background: limegreen; }
        #chart, #iqHealthChart, #envChart { margin: 20px 0; }
        .comparison { margin: 20px 0; padding: 10px; background: #e0f7fa; border: 1px solid #00acc1; }
        .level { margin: 10px 0; font-size: 1.2em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Verfeinerte Gamifizierte Simulation: Re-Migration bis 2050 & Volkshygiene mit Umweltauswirkungen</h1>
        <p>Integriert Re-Migration (inspiriert von migrant-chart) mit Polygynie, Gesundheit/IQ-Stabilisierung durch Heterosis vs. Degeneration, Subsidien (wie Riester) und Umweltauswirkungen (CO2-Emissionen).</p>
        
        <!-- Sliders -->
        <label>Startpopulation: <span id="startPopVal">100000</span></label>
        <input type="range" class="slider" id="startPop" min="10000" max="1000000" value="100000">

        <label>Fertilität Monogamie: <span id="fertMonoVal">1.5</span></label>
        <input type="range" class="slider" id="fertMono" min="1.0" max="3.0" step="0.1" value="1.5">

        <label>Fertilität Poly: <span id="fertPolyVal">2.5</span></label>
        <input type="range" class="slider" id="fertPoly" min="1.0" max="4.0" step="0.1" value="2.5">

        <label>Adoption Basis (%): <span id="adoptBaseVal">5</span></label>
        <input type="range" class="slider" id="adoptBase" min="0" max="20" value="5">

        <label>Adoption Hoch (%): <span id="adoptHighVal">10</span></label>
        <input type="range" class="slider" id="adoptHigh" min="0" max="20" value="10">

        <label>Generationen: <span id="gensVal">10</span></label>
        <input type="range" class="slider" id="gens" min="1" max="20" value="10">

        <label>Künstliche Befruchtung Boost: <span id="aiFertVal">1.5</span></label>
        <input type="range" class="slider" id="aiFert" min="1.0" max="2.0" step="0.1" value="1.5">

        <label>Re-Migration Rate bis 2050 (% Reduktion): <span id="reMigVal">50</span></label>
        <input type="range" class="slider" id="reMig" min="0" max="100" value="50">

        <label>Inzucht-Reduktion (%): <span id="inzuchtRedVal">20</span></label>
        <input type="range" class="slider" id="inzuchtRed" min="0" max="50" value="20">

        <label>Heterosis-Boost: <span id="heterosisVal">1.2</span></label>
        <input type="range" class="slider" id="heterosis" min="1.0" max="1.5" step="0.1" value="1.2">

        <label>Subsidien-Boost (z.B. Riester): <span id="subsidyVal">1.2</span></label>
        <input type="range" class="slider" id="subsidy" min="1.0" max="1.5" step="0.1" value="1.2">

        <label>Polyandrie-Modus (0=Polygynie, 1=Polyandrie): <span id="polyandryVal">0</span></label>
        <input type="range" class="slider" id="polyandry" min="0" max="1" step="1" value="0">

        <label>Initialer Ursprungsanteil (%): <span id="originShareVal">70</span></label>
        <input type="range" class="slider" id="originShare" min="50" max="90" value="70">

        <label>CO2 per Capita (Tonnen/Jahr): <span id="co2PerCapVal">4.1</span></label>
        <input type="range" class="slider" id="co2PerCap" min="1" max="20" step="0.1" value="4.1">

        <label>Land: </label>
        <select id="country">
            <option value="DE">Deutschland (83M, 70% Ursprung, CO2 ~4.1)</option>
            <option value="US">USA (340M, 59% Weiß, CO2 ~14.9)</option>
        </select>

        <button id="simulateBtn">Simulieren!</button>
        
        <!-- Tabelle -->
        <table id="resultTable"></table>
        
        <!-- Charts -->
        <canvas id="populationChart" width="800" height="400"></canvas>
        <canvas id="iqHealthChart" width="800" height="400"></canvas>
        <canvas id="envChart" width="800" height="400"></canvas>
        
        <!-- Score & Level -->
        <div id="score" class="level"></div>
        
        <!-- Download -->
        <button id="downloadBtn">Tabelle als CSV downloaden</button>
        
        <!-- Vergleich -->
        <div class="comparison">
            <h2>Hinweise zu Umweltauswirkungen & Volkshygiene</h2>
            <p>Fiktiv: Re-Migration reduziert Inzucht-Risiken, stabilisiert IQ (Heterosis-Boost). Subsidien (wie Riester) machen Modelle persistent. Umweltauswirkungen: Pop-Wachstum erhöht CO2, Re-Migration senkt es.</p>
        </div>
    </div>

    <script>
        // Globale Konstanten und Variablen
        const DEFAULTS = {
            startPop: 100000,
            fertMono: 1.5,
            fertPoly: 2.5,
            adoptBase: 5,
            adoptHigh: 10,
            gens: 10,
            aiFert: 1.5,
            reMig: 50,
            inzuchtRed: 20,
            heterosis: 1.2,
            subsidy: 1.2,
            polyandry: 0,
            originShare: 70,
            co2PerCap: 4.1
        };

        let myChart, iqHealthChart, envChart;

        // Initialisiere Sliders und Listener
        function initSliders() {
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                const valId = slider.id + 'Val';
                const valSpan = document.getElementById(valId);
                if (valSpan) valSpan.innerText = slider.value;
                slider.addEventListener('input', () => {
                    valSpan.innerText = slider.value;
                });
            });

            document.getElementById('country').addEventListener('change', updateCo2PerCap);
            document.getElementById('simulateBtn').addEventListener('click', simulate);
            document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
        }

        function updateCo2PerCap() {
            const country = document.getElementById('country').value;
            const co2Slider = document.getElementById('co2PerCap');
            co2Slider.value = country === 'US' ? 14.9 : 4.1;
            document.getElementById('co2PerCapVal').innerText = co2Slider.value;
        }

        // Wachstumsberechnung (Modularisiert)
        function calculateGrowth(startPop, fert, adopt, extra = 1, reMig, inzuchtRed, heterosis, co2PerCap) {
            let pop = [startPop];
            let iq = [100];
            let health = [80];
            let origin = [Math.round(startPop * (document.getElementById('originShare').value / 100))];
            let co2 = [startPop * co2PerCap / 1000000];
            const gens = parseInt(document.getElementById('gens').value);
            for (let g = 1; g <= gens; g++) {
                let baseGrowth = pop[g-1] * (fert / 2) * reMig;
                let adoptAdd = baseGrowth * adopt;
                let newPop = Math.round((baseGrowth + adoptAdd) * extra);
                pop.push(newPop);
                iq.push(iq[g-1] + (heterosis - 1) * 1 - (1 - inzuchtRed) * 0.5);
                health.push(health[g-1] + inzuchtRed * 2);
                origin.push(Math.round(origin[g-1] * (fert / 2) * extra * 0.99));
                let envEff = (1 - inzuchtRed) * heterosis * reMig;
                co2.push((newPop * co2PerCap / 1000000) * envEff);
            }
            return {pop, iq, health, origin, co2};
        }

        // Tabelle bauen
        function buildTable(mono, polyStd, polyPrimo, gens) {
            let table = '<tr><th>Gen</th><th>Mono Pop</th><th>Mono IQ</th><th>Mono Health %</th><th>Mono CO2 (Mt)</th><th>Poly Std Pop</th><th>Poly Std IQ</th><th>Poly Std Health %</th><th>Poly Std CO2 (Mt)</th><th>Poly Primo Pop</th><th>Poly Primo IQ</th><th>Poly Primo Health %</th><th>Poly Primo CO2 (Mt)</th><th>Score</th></tr>';
            for (let g = 0; g <= gens; g++) {
                let score = 'Stabil';
                let badgeClass = 'stable';
                let growthRate = (polyPrimo.pop[g] / mono.pop[0]) * 100;
                let co2Rate = polyPrimo.co2[g];
                if (growthRate > 200) { score = 'Boom - Volkshygiene-Optimiert!'; badgeClass = 'boom'; }
                if (growthRate < 100) { score = 'Kollaps'; badgeClass = 'collapse'; }
                if (polyPrimo.iq[g] < 100) { score += ' (Degenerationsrisiko)'; badgeClass = 'risk'; }
                if (co2Rate < polyStd.co2[g]) { score += ' (Grüner Boom)'; badgeClass = 'green'; }
                table += `<tr><td>${g}</td><td>${mono.pop[g]}</td><td>${mono.iq[g]}</td><td>${mono.health[g]}</td><td>${mono.co2[g].toFixed(2)}</td><td>${polyStd.pop[g]}</td><td>${polyStd.iq[g]}</td><td>${polyStd.health[g]}</td><td>${polyStd.co2[g].toFixed(2)}</td><td>${polyPrimo.pop[g]}</td><td>${polyPrimo.iq[g]}</td><td>${polyPrimo.health[g]}</td><td>${polyPrimo.co2[g].toFixed(2)}</td><td><span class="badge ${badgeClass}">${score}</span></td></tr>`;
            }
            document.getElementById('resultTable').innerHTML = table;
        }

        // Charts rendern
        function renderCharts(mono, polyStd, polyPrimo, gens) {
            const labels = Array.from({length: gens+1}, (_, i) => i);

            // Population Chart
            const popCtx = document.getElementById('populationChart').getContext('2d');
            if (myChart) myChart.destroy();
            myChart = new Chart(popCtx, {
                type: 'line',
                data: { labels, datasets: [
                    { label: 'Monogamie', data: mono.pop, borderColor: 'green' },
                    { label: 'Poly Std', data: polyStd.pop, borderColor: 'blue' },
                    { label: 'Poly Primo & Re-Mig', data: polyPrimo.pop, borderColor: 'red' }
                ] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            // IQ/Gesundheit Chart
            const iqHealthCtx = document.getElementById('iqHealthChart').getContext('2d');
            if (iqHealthChart) iqHealthChart.destroy();
            iqHealthChart = new Chart(iqHealthCtx, {
                type: 'line',
                data: { labels, datasets: [
                    { label: 'Primo IQ', data: polyPrimo.iq, borderColor: 'purple' },
                    { label: 'Primo Health %', data: polyPrimo.health, borderColor: 'orange' }
                ] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            // Umwelt Chart (CO2)
            const envCtx = document.getElementById('envChart').getContext('2d');
            if (envChart) envChart.destroy();
            envChart = new Chart(envCtx, {
                type: 'line',
                data: { labels, datasets: [
                    { label: 'Mono CO2 (Mt)', data: mono.co2, borderColor: 'brown' },
                    { label: 'Poly Primo CO2 (Mt)', data: polyPrimo.co2, borderColor: 'green' }
                ] },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        // Score und Level berechnen
        function getScoreLevel(polyPrimo, startPop, reMig, polyStd) {
            const gens = parseInt(document.getElementById('gens').value);
            const level = reMig < 0.8 && polyPrimo.iq[gens] > 105 && polyPrimo.co2[gens] < polyStd.co2[gens] ? 'Volkshygiene-Meister: Persistent, Positiv & Grün!' : 'Basis Level';
            document.getElementById('score').innerHTML = `<h3>${level} - Gesamtscore: ${polyPrimo.pop[gens] > startPop * 2 ? 'Boom!' : 'Stabil'}</h3>`;
        }

        // Haupt-Simulationsfunktion
        function simulate() {
            let startPop = parseInt(document.getElementById('startPop').value);
            const country = document.getElementById('country').value;
            if (country === 'US') startPop = 340000000;
            const fertMono = parseFloat(document.getElementById('fertMono').value);
            const fertPoly = parseFloat(document.getElementById('fertPoly').value);
            const adoptBase = parseFloat(document.getElementById('adoptBase').value) / 100;
            const adoptHigh = parseFloat(document.getElementById('adoptHigh').value) / 100;
            const gens = parseInt(document.getElementById('gens').value);
            const aiFert = parseFloat(document.getElementById('aiFert').value);
            const reMig = 1 - (parseFloat(document.getElementById('reMig').value) / 100);
            const inzuchtRed = parseFloat(document.getElementById('inzuchtRed').value) / 100;
            const heterosis = parseFloat(document.getElementById('heterosis').value);
            const subsidy = parseFloat(document.getElementById('subsidy').value);
            const polyandry = parseInt(document.getElementById('polyandry').value);
            const co2PerCap = parseFloat(document.getElementById('co2PerCap').value);
            const polyFactor = polyandry ? 1.1 : 1.2;
            const stabilityFactor = 1.3 * aiFert * subsidy * heterosis * (1 + inzuchtRed);

            const mono = calculateGrowth(startPop, fertMono, adoptBase, 1, reMig, inzuchtRed, heterosis, co2PerCap);
            const polyStd = calculateGrowth(startPop, fertPoly, adoptBase, 1 / polyFactor, reMig, inzuchtRed, heterosis, co2PerCap);
            const polyPrimo = calculateGrowth(startPop, fertPoly, adoptHigh, stabilityFactor / polyFactor, reMig, inzuchtRed, heterosis, co2PerCap);

            buildTable(mono, polyStd, polyPrimo, gens);
            renderCharts(mono, polyStd, polyPrimo, gens);
            getScoreLevel(polyPrimo, startPop, reMig, polyStd);
        }

        // CSV-Download
        function downloadCSV() {
            const rows = Array.from(document.querySelectorAll('#resultTable tr'));
            let csv = rows.map(row => Array.from(row.cells).map(cell => cell.innerText).join(',')).join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'simulation.csv';
            a.click();
        }

        // Initialisierung
        initSliders();
    </script>
</body>
</html>
